# -*- indent-tabs-mode: nil; -*-
#+TITLE: Jassob's Emacs configuration
#+DATE: <2018-01-19 Fri>

* About this file
  This file is intended to be the configurable point of my Emacs
  configuration.

  The complete configuration is very much inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's
  Emacs Configuration]], especially =org-mode=, with some stolen bits
  and pieces from both [[http://spacemacs.org][Spacemacs]]/[[https://github.com/TheBB/spaceline][Spaceline]] and [[https://github.com/hlissner/.emacs.d][hlissner's Emacs
  config]].

  This file generates my config by tangling all source code blocks in
  the text to a single elisp-file.

* Setup
  There is a Makefile that tangles everything that needs to be tangled.

  1. Clone this repository to =/.emacs.d/= (backup your own configuration first!)
  2. Run ~make all~ in =~/.emacs.d/
  3. Profit!

* Initialization

  Before doing anything else, let us disable the garbage collector
  during setup, this saves us some time and we're not likely to run in
  to memory issues while setting everything up.

  #+begin_src emacs-lisp :tangle init.el
    (setq gc-cons-threshold (* 100 (expt 10 6)) ; 100 MB
          gc-cons-percentage 0.8)

    ;; restore after startup
    (add-hook 'after-init-hook
              (lambda () (setq gc-cons-threshold (* 50 (expt 20 6)) ; 50 MB
                               gc-cons-percentage 0.1)))

    ;; Increase the amount of data read from subprocesses
    (setq read-process-output-max (* 1 (expt 10 6))) ; 1MB
  #+end_src

** Packages

   Then we'll mark that we've initialized packages outside package.el.

   #+begin_src emacs-lisp :tangle init.el
     (require 'package)
     (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
   #+end_src

   Make sure to reload the list of packages by calling =M-x
   package-refresh-contents= when adding melpa for the first time.

   I use =use-package= for keeping track of my packages, customising
   them and load them lazily.

   #+begin_src emacs-lisp :tangle init.el
     (require 'use-package)
     ;; Always install all packages, but defer them until they are needed
     (setq use-package-always-ensure t
           use-package-always-defer t)
   #+end_src

   Make sure that =use-package= is available for the byte-compiler.

   #+begin_src emacs-lisp :tangle init.el
     (eval-when-compile
       (require 'use-package))
     (require 'bind-key)
   #+end_src

   Delight is a nice package for hiding stuff in my modeline.

   #+begin_src emacs-lisp :tangle init.el
     (use-package delight :commands (delight))
   #+end_src

** Editing system files

   When I edit system configuration files I might accidentally find
   files as my regular user, even though I need sudo rights to edit
   them. This advice makes =find-file= automatically open it through
   =TRAMP= as sudo if it is not writable by my user.

   #+begin_src emacs-lisp :tangle init.el
     (defadvice find-file (after find-file-sudo activate)
       "Find file as root if necessary."
       (when (and buffer-file-name
                  (not (file-writable-p buffer-file-name))
                  (y-or-n-p "Do you want to edit as sudo?"))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+end_src

** Backups and auto-save

   Emacs should not litter the working directory by creating auto-save files and
   backups there.

   #+begin_src emacs-lisp :tangle init.el
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
           auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "backups") t))
           undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
   #+end_src

** Encoding system
   We would like Emacs to prefer UTF8 when reading ambiguous bit
   strings.

   #+begin_src emacs-lisp :tangle init.el
     (prefer-coding-system 'utf-8)
     (when (display-graphic-p)
       (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
   #+end_src

** Buffer and window navigation

   Switching between windows can be a bit of a pain, just cycling
   through them with =C-x o= is not really good enough. I therefore
   use ~windmove~ and ~buffer-move~ to navigate amongst my buffers and
   I have them bound to, in my opinion at least, sensible keybindings.

   #+begin_src emacs-lisp :tangle init.el
     (bind-keys ("C-x <left>"  . windmove-left)
                ("C-x <up>"    . windmove-up)
                ("C-x <down>"  . windmove-down)
                ("C-x <right>" . windmove-right))
   #+end_src

   Sometimes it is nice to be able to shrink and enlarge windows
   easily and that is why I've bounded them to simple keys:

   #+begin_src emacs-lisp :tangle init.el
     (bind-keys ("S-C-<left>"  . shrink-window-horizontally)
                ("S-C-<right>" . enlarge-window-horizontally)
                ("S-C-<down>"  . shrink-window)
                ("S-C-<up>"    . enlarge-window))
   #+end_src

** Dired

   Dired is file manager and browser built into Emacs and it is
   efficient enough. By default it shows every file, even hidden ones,
   which results in a lot of noise.

   #+begin_src emacs-lisp :tangle init.el
     (require 'dired-x)
     (setq dired-omit-files "^\\...+$")
     (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
     (define-key dired-mode-map (kbd "C-c h") 'dired-omit-mode)
   #+end_src

   Now, pressing =C-c h= will hide all hidden files in Dired.

** Parsing to terminal keys correctly

   Sometimes my terminal sends garbled keys to Emacs, to make Emacs
   understand the terminal I extend the ~input-decode-map~.

   How to add more keys:
   1. In the scratch buffer: C-q $COMBINATION
   2. Add the binding to ~input-decode-map~.
   3. Profit!

   Credits: [[https://emacs.stackexchange.com/a/989][This fine answer on Emacs stack exchange]]

   #+begin_src emacs-lisp :tangle init.el
     ;; shift + arrow keys
     (define-key input-decode-map "\[1;2D" [S-left])
     (define-key input-decode-map "\[1;2A" [S-up])
     (define-key input-decode-map "\[1;2C" [S-right])
     (define-key input-decode-map "\[1;2B" [S-down])

     ;; ctrl + arrow keys
     (define-key input-decode-map "\[1;5D" [C-left])
     (define-key input-decode-map "\[1;5A" [C-up])
     (define-key input-decode-map "\[1;5C" [C-right])
     (define-key input-decode-map "\[1;5B" [C-down])

     ;; meta + arrow keys
     (define-key input-decode-map "\[1;3D" [M-left])
     (define-key input-decode-map "\[1;3A" [M-up])
     (define-key input-decode-map "\[1;3C" [M-right])
     (define-key input-decode-map "\[1;3B" [M-down])

     ;; shift + ctrl + arrow keys
     (define-key input-decode-map "\[1;6D" [S-C-left])
     (define-key input-decode-map "\[1;6A" [S-C-up])
     (define-key input-decode-map "\[1;6C" [S-C-right])
     (define-key input-decode-map "\[1;6B" [S-C-down])

     ;; shift + meta + arrow keys
     (define-key input-decode-map "\[1;4D" [S-M-left])
     (define-key input-decode-map "\[1;4A" [S-M-up])
     (define-key input-decode-map "\[1;4C" [S-M-right])
     (define-key input-decode-map "\[1;4B" [S-M-down])
   #+end_src

** Interacting with X clipboard in terminal

   When I run Emacs in terminal mode I still want to be able to copy
   stuff to the X clipboard. =xclip= is a package that does just that.

   #+begin_src emacs-lisp :tangle init.el
     (use-package xclip :init (xclip-mode t))
   #+end_src

** Custom file

   Don't store user-defined settings and other custom things in the
   config (which will be read-only on some systems), but instead in
   another file.

   #+begin_src emacs-lisp :tangle init.el
     (setq custom-file (concat user-emacs-directory "custom.el"))
     (load-file custom-file)
   #+end_src

** Dealing with Emacs server directory permissions

   For some reason the `/run/user/$UID/emacs` directory sometimes has
   the permissions =u+rx= instead of =u+rwx=, which causes Emacs to
   not be able to write its server file.

   #+begin_src emacs-lisp :tangle init.el
     (defun jsb/ensure-permission (dir mode)
       "Checks that DIR has permissions MODE set and sets it if missing."
       (unless (file-exists-p dir)
         (mkdir dir))
       (let ((current-mode (file-modes dir)))
         (unless (= current-mode mode)
           (chmod dir mode))))

     ;; Ensure that the permissions are correct before starting the server.
     (advice-add 'server-start :before
                 (lambda (&optional LEAVE-DEAD INHIBIT-PROMPT)
                   (jsb/ensure-permission server-socket-dir #o700)))
   #+end_src

** Completions

   ~fido-vertical-mode~ is a builtin package providing a vertical list
   of completion candidates for the minibuffer.

  #+begin_src emacs-lisp :tangle init.el
    ;; List minibuffer candidates in vertical list
    (fido-vertical-mode)
  #+end_src

  It is usually convenient to get my most frequently used commands at
  the top of the suggestions, ~smex~ is a package that does just that
  for M-x.

  #+begin_src emacs-lisp :tangle init.el
    ;; Use smex to keep M-x sorted on recent use
    (use-package smex)
  #+end_src

** Tree-like file history

   I find Emacs default undo behaviour rather intuitive (of course a
   redo is just an undo of your last undo!), but I like being able to
   visualise the timeline of my file. Enters =vundo=!

   #+begin_src emacs-lisp :tangle init.el
     ;; Display local file history as tree of edits
     (use-package vundo :delight :commands (vundo) :bind ("C-x u" . vundo))
   #+end_src

** Secrets and custom settings

   I store more sensitive data in =~/.emacs.d/etc/.secrets.el= so I
   easily can store my main configuration in a public version control
   system.

   #+begin_src emacs-lisp :tangle init.el
     (load (concat user-emacs-directory ".secrets.el") t)
   #+end_src

** Key stroke reminders

  To help me remember my commands I use =which-key=, which displays a
  popup showing all the keybindings belonging to a prefix key.

  #+begin_src emacs-lisp :tangle init.el
    (use-package which-key :delight
      :init (which-key-mode)
      :config (setq which-key-idle-delay 2.0))
  #+end_src

* Handling character pairs

  Emacs has a great package for dealing with characters that comes in
  pairs, ~smartparens~. Smartparens lets us navigate with and
  manipulate parens, quotes etc.

  #+begin_src emacs-lisp :tangle init.el
    (use-package smartparens :delight
      :init (require 'smartparens-config)
      :hook ((prog-mode-hook . 'turn-on-smartparens-strict-mode)
             (minibuffer-setup-hook . 'turn-on-smartparens-strict-mode))
      :config (show-smartparens-global-mode t)
      :bind (:map smartparens-mode-map
                  ("M-<left>" . sp-backward-slurp-sexp)
                  ("C-M-<left>" . sp-backward-barf-sexp)
                  ("M-<right>" . sp-forward-slurp-sexp)
                  ("C-M-<right>" . sp-forward-barf-sexp)))
  #+end_src

  One really nifty feature is that we can edit multiple lines at once
  with =multiple-cursors=.

  =M-n= creates a new cursor on the next line (or tries to find a
  matching token if you've selected anything) and =M-p= does the same,
  but looking behind the mark.

  #+begin_src emacs-lisp :tangle init.el
    (use-package multiple-cursors
      :bind (:map global-map
                  ("C-S-c C-S-c" . mc/edit-lines)
                  ("M-n" . mc/mark-next-symbol-like-this)
                  ("M-p" . mc/mark-previous-symbol-like-this)
                  ("C-c M-n" . mc/mark-next-like-this)
                  ("C-c M-p" . mc/mark-previous-like-this)
                  ("C-," . mc/mark-pop)
                  ("M-<mouse-1>" . mc/add-cursor-on-click)))
  #+end_src

* Coding settings

  There are some common things I want to use for all every
  programming language I code in. For instance I would like error
  checking and auto-completion when it exists and line indicators
  that shows if a line is modified, added or removed.

  Worth noting is that I turn off Transient Mark mode in Common-Code
  minor mode, because I like to use the tag stack for navigation (i.e
  activating a mark = temporarily "bookmark" current position,
  popping marker stack = jumping to last "bookmark). Besides the
  original behaviour (i.e beginning a region) is still available on
  =C-SPC C-SPC=.

  #+begin_src emacs-lisp :tangle init.el
    (if (>= emacs-major-version 26)
        (add-hook 'prog-mode-hook 'display-line-numbers-mode)
      (progn
        (add-hook 'prog-mode-hook 'linum-mode)))
    (add-hook 'prog-mode-hook (lambda () (transient-mark-mode -1)))
    (setq company-idle-delay nil)

  #+end_src

  I want trailing white space to be removed automatically before saving.

  #+begin_src emacs-lisp :tangle init.el
    (add-hook 'prog-mode-hook
              (lambda () (add-hook 'before-save-hook #'delete-trailing-whitespace)))
  #+end_src

  Other minor modes I want to have active in programming modes:

  #+begin_src emacs-lisp :tangle init.el
    ;;; Built into Emacs
    (use-package hs-minor-mode :hook prog-mode :delight :bind (("C-<tab>" . #'hs-toggle-hiding)) :ensure nil)
    (use-package subword-mode :hook prog-mode :delight :ensure nil)
    (use-package hl-line-mode :hook prog-mode :delight :ensure nil)
    (use-package column-number-mode :hook prog-mode :delight :ensure nil)

    ;; Automatically revert file when changed outside of Emacs
    (use-package autorevert :delight auto-revert-mode :hook (prog-mode . auto-revert-mode))

    (use-package hl-todo :delight :hook (prog-mode . hl-todo-mode))

    (use-package projectile :delight :commands (projectile-mode)
      :init (projectile-mode)
      :bind (("C-c p" . projectile-command-map)
             ("M-p" . projectile-command-map)))
    (use-package rg
      ;; Don't ignore hidden files
      :config (add-to-list 'rg-command-line-flags "-."))

    (use-package company :delight :hook (prog-mode . company-mode)
      :bind (:map prog-mode-map (("C-c RET" . company-complete)
                                 ("C-c C-RET" . company-complete))))

    (use-package rainbow-delimiters :delight :hook (prog-mode . rainbow-delimiters-mode))

    (use-package yasnippet :commands (yas-reload-all yas-minor-mode)
      :config (yas-reload-all))
  #+end_src

  Sometimes it is handy to be able to open the current line or region
  inside a browser.

  #+begin_src emacs-lisp :tangle init.el
    (defun jsb/clean-git-url (git-url)
      (string-replace ".git" "" (string-replace "git@github.com:" "https://github.com/" git-url)))

    ;; Inspiration from https://www.reddit.com/r/emacs/comments/xdw6ok/comment/iodig8c
    (defun open-on-github ()
      (interactive)
      (require 'magit)
      (let ((repo-url  (jsb/clean-git-url (magit-git-string "remote" "get-url" "--push" "origin")))
            (commit-hash (magit-git-string "rev-parse" "HEAD"))
            (start-line (if (use-region-p) (line-number-at-pos (region-beginning)) (line-number-at-pos)))
            (end-line (if (use-region-p) (line-number-at-pos (region-end))))
            (file-name (substring buffer-file-name (length (projectile-project-root)))))
        (unless repo-url (error  "not in a git repo"))
        (browse-url (concat repo-url "/blob/" commit-hash "/" file-name "#L" (number-to-string start-line)
                            (if (and (use-region-p) (< 0 (- end-line start-line)))
                                (concat "..L" (number-to-string end-line)))))))
  #+end_src


  When LSP is not setup correctly Xref falls back to navigating the
  source tree with TAGS, and these files seldom exists.
  With =dumb-jump= we get some heuristics that jumps to somewhat
  reasonable places and allows us to use Xref without LSP setup
  properly.

  #+begin_src emacs-lisp :tangle init.el
    (use-package dumb-jump :commands (dump-jump-xref-activate)
      :init (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
  #+end_src

** LSP

  Quite a few of the programming languages I work with supports LSP,
  Microsoft's Language Server Protocol, and wiring it ~prog-mode~
  makes sense.

  I'm currently experimenting with both =lsp-mode= and =eglot= to
  figure out which implementation I prefer. In both cases I want the
  underlying choice to be more or less transparent to me.

  Let's start with configuring eglot:
  #+begin_src emacs-lisp :tangle init.el
    (use-package eglot :commands (eglot-ensure
                                  eglot-code-actions
                                  eglot-code-action-organize-imports
                                  eglot-rename
                                  eglot format
                                  eglot-format-buffer)
      :hook ((eglot-managed-mode . (lambda () (add-hook 'before-save-hook #'eglot-format 0 t))))
      :bind (:map eglot-mode-map
                  ("C-c l a a" . eglot-code-actions)
                  ("C-c l a i" . eglot-code-action-organize-imports)
                  ("C-c ! l"   . flymake-show-buffer-diagnostics)
                  ("C-c ! a"   . flymake-show-project-diagnostics)
                  ("C-c ! n"   . flymake-goto-next-error)
                  ("C-c ! p"   . flymake-goto-prev-error)
                  ("C-c l r r" . eglot-rename)
                  ("C-c l f f" . eglot-format)
                  ("C-c l f b" . eglot-format-buffer)))
  #+end_src

  Next comes =lsp-mode=:

  #+begin_src emacs-lisp :tangle init.el
    (use-package lsp-mode :commands (lsp lsp-deferred)
      :init (setq lsp-keymap-prefix (kbd "C-c l"))
      :bind (:map lsp-mode-map
                  ("C-c ! l"   . flymake-show-buffer-diagnostics)
                  ("C-c ! a"   . flymake-show-project-diagnostics)
                  ("C-c ! n"   . flymake-goto-next-error)
                  ("C-c ! p"   . flymake-goto-prev-error)))
  #+end_src

  There seems to be a bug in treemacs, related to SVG images.

  #+begin_src emacs-lisp :tangle init.el
    (add-to-list 'image-types 'svg)
  #+end_src

  Now, let's configure the various modes to actually start the
  expected =lsp= implementation.

  #+begin_src emacs-lisp :tangle init.el
    ;; Define LSP functions for modes
    (setq jsb/lsp-mode-alist '((go-mode-hook . eglot-ensure)
                                 (rust-mode-hook . eglot-ensure)
                                 (c-mode-hook . eglot-ensure)
                                 (typescript-mode-hook . lsp-deferred)
                                 (java-mode-hook . lsp-deferred)))

    ;; Register the LSP functions for the different modes
    (mapcar (lambda (pair) (add-hook (car pair) (cdr pair))) jsb/lsp-mode-alist)
  #+end_src

** Formatting

   #+begin_src emacs-lisp :tangle init.el
     (defun jsb/format-code ()
       "Format buffer using formatter in assoc-list prog-mode-formatters..

     prog-mode-formatters is an assoc-list on the form 'major-mode
     . formatting-call' and formatting-call is invoked with '(funcall).'
     "
       (interactive)
       (if (not (boundp 'prog-mode-formatters))
           (warn "No formatters configured")
         (let ((formatter (assoc major-mode prog-mode-formatters)))
           (if (eq nil formatter)
               (warn "No formatter configured for mode %s" major-mode)
             (funcall (cdr formatter))))))

     ;; Bind it to our formatting key-binding
     (define-key prog-mode-map (kbd "C-c C-f") 'jsb/format-code)
   #+end_src

   For C and Java we want to use Clang-format for formatting, Go and
   Rust will continue to use their respective *fmt binaries.

   #+begin_src emacs-lisp :tangle init.el
     (use-package clang-format :commands 'clang-format-buffer)

     (defvar prog-mode-formatters '((c-mode . clang-format-buffer)
                                    (java-mode . clang-format-buffer)
                                    (go-mode . gofmt)
                                    (rust-mode . rust-format-buffer)
                                    (typescript-mode . prettier-prettify))
       "Alist containing major-mode and formatter pairs.")
   #+end_src

** Version control

   I mostly use [[https://git-scm.com/][Git]] to handle my version control and while it
   certainly got somewhat of a steep learning curve and a few rough
   edges here and there I mostly find it intuitive.

   To help me manage my Git repositories I use the fantastic package
   =magit=, which is a Git frontend to Emacs and one of the few Git
   frontends I really like.

   #+begin_src emacs-lisp :tangle init.el
     (use-package magit :bind ("C-x g" . magit-status))
   #+end_src

   =Git-gutter+= is a package that shows a line's status (added,
   modifid or deleted) in a file that is version controlled by Git.

   #+begin_src emacs-lisp :tangle init.el
     (use-package git-gutter :delight t
       :hook (prog-mode . git-gutter-mode)
       :bind (:map prog-mode-map
                   ;; Navigate on hunks
                   ("C-x v n"   . git-gutter:next-hunk)
                   ("C-x v p"   . git-gutter:previous-hunk)
                   ;; Act on hunks
                   ("C-x v =" . git-gutter:popup-hunk)
                   ("C-x v r"   . git-gutter:revert-hunk)
                   ("C-x v t"   . git-gutter:stage-hunk)
                   ("C-x v U"   . git-gutter:update-all-windows)))
   #+end_src

   To help me interact with my Github repositories I use =forge=.

   #+begin_src emacs-lisp :tangle init.el
     (use-package forge :after magit)
   #+end_src

** Rust

   I want to format Rust buffers on save, and have the rest of the LSP
   experience with Rust, especially with rust-analyzer.

   #+begin_src emacs-lisp :tangle init.el
     (use-package rust-mode
       :init (setq rust-format-on-save t
                   rust-format-show-buffer nil
                   rust-format-goto-problem nil
                   rust-mode-treesitter-derive t)
       :bind (:map rust-mode-map
                   ("C-c C-u" . jsb/rust-insert-todo)))

     (defun jsb/rust-insert-todo ()
       "Inserts todo!() into a buffer at point."
       (interactive)
       (insert "todo!()"))
  #+end_src

  =rustic= provides some more convenience functions like running the
  current test (=C-c C-c C-c=) and so on.

  #+begin_src emacs-lisp :tangle init.el
    (use-package rustic :after rust-ts-mode :defer t :init
      (setq rustic-lsp-client 'eglot)
      (add-hook 'rustic-mode-hook #'rustic-setup-eglot -10))
  #+end_src

  Finally, =cargo-mode= allows me to easily change and update
  Cargo.toml contents.

  #+begin_src emacs-lisp :tangle init.el
    (use-package cargo-mode :after rust-mode :defer t)
  #+end_src

** Golang

  This configuration sets up a Go mode where common-code minor mode is
  enabled together with a plethora of other useful stuff, such as
  linter and formatters etc.

  First let's start with fixing the project/module location.

  #+begin_src emacs-lisp :tangle init.el
    ;; Go defines a module (or project in Eglot lingo) to be whatever
    ;; directory that contains a go.mod file.
    (require 'project)

    (defun project-find-go-module (dir)
      (when-let ((root (locate-dominating-file dir "go.mod")))
        (cons 'go-module root)))

    (cl-defmethod project-root ((project (head go-module)))
      (cdr project))
  #+end_src

  Then, let me configure Go mode to use Eglot.

  #+begin_src emacs-lisp :tangle init.el
    (use-package go-mode :mode "\\.go\\'" :after eglot
      :bind (:map go-mode-map (("C-c C-k" . godoc)
                               ("C-c C-u" . jsb/go-insert-todo)))
      :hook (
             (go-mode . (lambda () (add-hook 'before-save-hook #'eglot-format-buffer -10 t)))
             (go-mode . (lambda () (add-hook 'project-find-functions #'project-find-go-module -10 t)))
             (go-mode . (lambda () (setq-default eglot-workspace-configuration
                                         '(:gopls (:buildFlags ["-tags=integration"]
                                                   :gofumpt t
                                                   :staticcheck t
                                                   :codelenses ((gc_details . t) (tidy . t) (run_vulncheck . t) (test . t))
                                                   :matcher  "CaseSensitive")))))))

    (defun jsb/go-insert-todo ()
      "Inserts panic(\"todo\") in the buffer at point."
      (interactive)
      (insert "panic(\"todo\")"))
  #+end_src

  At einride we use golangci-lint and I want Emacs to automatically
  pick up the correct binary and config file, if provided by the
  repository.

  #+begin_src emacs-lisp :tangle init.el
    (use-package flycheck-golangci-lint :after go-mode
      :config (setq flycheck-golangci-lint-deadline "10s")
      :hook ((go-mode . jsb/setup-sage-golangci-lint)
             (go-mode . flycheck-golangci-lint-setup)
             (go-mode . flycheck-mode)))


    (defun jsb/setup-sage-golangci-lint (&optional root-dir curr-dir)
      "Instructs flycheck-golangci-lint to use the shipped binary and
        config from a sage directory, if present."
      (interactive)
      ; Use the arguments if provided, otherwise default to project dir
      ; and buffer directory.
      (let ((sage-dir (concat (or root-dir (project-root (project-current))) ".sage/"))
            (current-dir (or curr-dir (file-name-directory (buffer-file-name)))))
        (let ((sage-golangci-lint-config (concat sage-dir "tools/golangci-lint/.golangci.yml"))
              (sage-golangci-lint-exe (concat sage-dir "bin/golangci-lint"))
              (local-golangci-lint-config (jsb/find-golangci-lint-config curr-dir root-dir)))
          ;; Set exe if exists
          (unless (jsb/set-local-if-exists 'flycheck-golangci-lint-executable sage-golangci-lint-exe)
            (message "Missing sage-provided golangci-lint binary, make sure to run `make`"))
          ;; Set config if exists
          (if local-golangci-lint-config
              (setq-local flycheck-golangci-lint-config local-golangci-lint-config)
            (unless (jsb/set-local-if-exists 'flycheck-golangci-lint-config sage-golangci-lint-config)
                (message "Missing golangci-lint config, falling back to default behavior"))))))

    (defun jsb/set-local-if-exists (var file)
      "Set VAR locally to FILE if FILE exists."
      (if (and (stringp file) (symbolp var))
        (if (file-exists-p file) (setq-local var file))
        (warn "Either FILE is not a string or VAR is not a symbol")))

    (defun jsb/find-golangci-lint-config (current-directory root-directory)
      "Selects the closest of any existing .golangci.yml files."
      (when (and current-directory root-directory)
        (let* ((relative-dir (file-relative-name current-directory root-directory))
               (candidate-dirs (append (list root-directory) (jsb/ancestor-paths relative-dir)))
               (candidates (mapcar (lambda (ancestor) (concat ancestor "/.golangci.yml")) candidate-dirs)))

          (jsb/return-first-file candidates))))

    (defun jsb/return-first-file (candidates)
      "Returns the first file that exists out of CANDIDATES."
      (catch 'first-match
        (dolist (candidate candidates)
          (when (file-exists-p candidate)
            (throw 'first-match candidate)))))

    (defun jsb/ancestor-paths (path)
      "Returns a list of all ancestors to PATH."
      (let (ancestors)
        (dolist (current-path (file-name-split path) ancestors)
          (add-to-list 'ancestors (if ancestors (concat (car ancestors) "/" current-path) current-path)))))
  #+end_src

  I want to be able to run tests directly from within Emacs.

  #+begin_src emacs-lisp :tangle init.el
    (use-package gotest :after go-mode :defer t
      :hook (go-mode . (lambda ()
                         (setq go-test-verbose t
                               go-test-args "-race -cover")))
      :bind (:map go-mode-map
                  ("C-c C-t t" . go-test-current-test)
                  ("C-c C-t f" . go-test-current-file)
                  ("C-c C-t p" . go-test-current-project)))

    (with-eval-after-load
     'gotest
     (defvar jsb/gotest-default-args '("-race" "-cover" "-count=1" "-timeout=30s")
       "Default arguments to gotest package, as a list.")

     (defun jsb/gotest-update-args ()
       "Update the gotest's go-test-args with our own jsb/gotest-arg-list"
       (setq go-test-args (string-join jsb/gotest-arg-list " ")))

     (defun jsb/gotest-reset-args ()
       "Resets go-test-args"
       (interactive)
       (setq jsb/gotest-arg-list jsb/gotest-default-args)
       (jsb/gotest-update-args))

     ;; Reset the args to the default
     (jsb/gotest-reset-args)

     (defun jsb/gotest-add-arg (arg)
       "Adds ARG to go-test-args. If ARG is present it will be replaced."
       (interactive "sArgument: ")
       (let* ((pairs (string-split arg "[= ]"))
    	  (filtered-args (cl-remove-if (lambda (arg) (string-prefix-p (car pairs) arg)) jsb/gotest-arg-list)))
         (setq jsb/gotest-arg-list (cons (string-join pairs "=") filtered-args))
         (jsb/gotest-update-args)))

     (defun jsb/gotest-add-build-tags (buildTag)
       "Adds BUILDTAG to go-test-args."
       (interactive "sBuild tag: ")
       (jsb/gotest-add-arg (concat "-tags=" buildTag)))

     (defun jsb/gotest-add-timeout (timeout)
       "Adds TIMEOUT to go-test-args."
       (interactive "sTimeout (with unit): ")
       (jsb/gotest-add-arg (concat "-timeout=" timeout)))
     )
  #+end_src

  Sometimes when testing I want to be able to debug the test cases and
  set breakpoints, for that I use =go-dlv= which let's me use the GUD
  interface.

  #+begin_src emacs-lisp :tangle init.el
    (use-package go-dlv :defer t :after go-mode :commands (dlv-current-func))
  #+end_src

** TypeScript and Web stuff

   The following configuration will ensure that tree-sitter’s
   dedicated tsx parser will be used for tsx (typescript + react)
   files. By default this currently is not the case, as it uses the
   typescript parser which does not understand the tsx extensions.

   I want to use eglot to setup my LSP server for (Java|Type)Script
   files, but it needs some workaround on NixOS systems:

   #+begin_src emacs-lisp :tangle init.el
     (defun jsb/generate-typescript-eglot-server-program ()
       "Generate the eglot-server-program entry for typescript-language-server.

     This might only be necessary on NixOS."
       (let ((path-to-typescript-language-server (executable-find "typescript-language-server"))
             (path-to-tsserver (executable-find "tsserver")))
         (unless path-to-typescript-language-server
           (error "Missing typescript-language-server, please install it"))
         (unless path-to-tsserver
           (error "Missing tsserver, please install it"))
         `((js-mode typescript-mode) .
           (,path-to-typescript-language-server
            "--stdio"
            "--tsserver-path"
            ,(expand-file-name "../../lib" (file-truename path-to-tsserver))))))
   #+end_src

   Here we create a new derived mode that will map to both .tsx and
   .ts. Due to the derived mode’s name, the typescript language server
   will select tsx support, and due to the the explicit mapping,
   tree-sitter will select its tsx parser.

   #+begin_src emacs-lisp :tangle init.el
     ;; https://vxlabs.com/2022/06/12/typescript-development-with-emacs-tree-sitter-and-lsp-in-2022/
     (use-package typescript-mode :defer t :hook (typescript-mode . eglot-ensure)
       :config
       (with-eval-after-load 'eglot (add-to-list 'eglot-server-programs (jsb/generate-typescript-eglot-server-program)))
       ;; we choose this instead of tsx-mode so that eglot can automatically figure out language for server
       ;; see https://github.com/joaotavora/eglot/issues/624 and https://github.com/joaotavora/eglot#handling-quirky-servers
       (define-derived-mode typescriptreact-mode typescript-mode "TypeScript TSX")

       ;; use our derived mode for tsx files
       (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescriptreact-mode)))
   #+end_src

   Let's make sure that we get prettier files.

   #+begin_src emacs-lisp :tangle init.el
     (use-package prettier :after typescript-mode
       :hook ((typescript-mode . prettier-mode)))
   #+end_src

** Infrastructure tools

   I want to have terraform HCL source code syntax highlighted.

   #+begin_src emacs-lisp :tangle init.el
     (use-package terraform-mode :defer t)
   #+end_src

   I also use saltstack and thus want some salt support too.

   #+begin_src emacs-lisp :tangle init.el
     (use-package salt-mode :defer t)
   #+end_src

   Other describing languages that I use are;

   #+begin_src emacs-lisp :tangle init.el
     (use-package protobuf-mode :defer t)
     (use-package toml-mode :defer t)
     (use-package dockerfile-mode :defer t)
   #+end_src

** Haskell

   I want to launch ~interactive-haskell-mode~ when I press <C-c C-l>.

   #+begin_src emacs-lisp :tangle init.el
     (use-package haskell-mode :defer t
       :mode "\\.hs\\'"
       :hook ((haskell-mode . interactive-haskell-mode)
              (haskell-mode . haskell-indentation-mode)
     	 (haskell-mode . (lambda () (lsp-deferred))))
       :init (setq lsp-haskell-formatting-provider "fourmolu"
     	      lsp-haskell-plugin-fourmolu-config-external t)
       :bind (:map haskell-mode-map
     	      ("C-c C-u" . jsb/haskell-insert-unimplemented)))

     (defun jsb/haskell-insert-unimplemented ()
       "Inserts error \"Not implemented.\" into a buffer at point."
       (interactive)
       (insert "error \"Not implemented\""))
   #+end_src

** Java

   I want to use =lsp-java= when programming in Java, because I don't
   feel the need to learn how to get Eglot to work with Java's
   pecularities.

   #+begin_src emacs-lisp :tangle init.el
     (use-package lsp-java :after lsp-mode :defer t)

     (add-hook 'java-mode-hook (lambda () (setq tab-width 8)))
   #+end_src

** Nix

   When editing =nix= source files I want syntax highlighting and
   other major mode perks from =nix-mode=.

   #+begin_src emacs-lisp :tangle init.el
     (use-package nix-mode :defer t)
   #+end_src

* Personal customization
  Give my setup a personal touch.

  #+begin_src emacs-lisp :tangle init.el
     (setq user-full-name "Jacob Jonsson"
       user-mail-address "jacob.t.jonsson@gmail.com")
  #+end_src

  I don't like to type more than necessary, so why do I need to type
  1-2 extra letters when the first letter is enough?

  #+begin_src emacs-lisp :tangle init.el
     (fset 'yes-or-no-p 'y-or-n-p)
  #+end_src

  I've seen the splash screen enough times now, please don't show it
  to me anymore.

  #+begin_src emacs-lisp :tangle init.el
     (setq inhibit-splash-screen t)
  #+end_src

  Now that I'm trying out Dvorak (Svorak A5) these changes makes the
  transition between key layouts easier.

  #+begin_src emacs-lisp :tangle init.el
    ;; Bind C-z to C-x
    (global-set-key (kbd "C-z") ctl-x-map)

    ;; Bind C-h to previous-line since C-p is no longer on the same half
    ;; of the keyboard
    (global-set-key (kbd "C-x C-h") help-map)
    (global-set-key (kbd "C-h") 'previous-line)
  #+end_src

  When modifying a file Emacs creates a hidden lock symlink pointing
  to the modified file. This is probably nice when you don't want to
  accidentally open an unsaved and modified file in another Emacs
  instance, but it also breaks tools that watches file modifications
  in a directory. Therefore I choose to disable it.

  #+begin_src emacs-lisp :tangle init.el
    (setq create-lockfiles nil)
  #+end_src

  There are sometimes when I need to interact with external programs.
  For instance I sometimes like to open URL's in a more capable
  browser than EWW (even though it is very good!).

  #+begin_src emacs-lisp :tangle init.el
    (setq browse-url-browser-function 'browse-url-default-browser
          browse-url-new-window-flag  t)
  #+end_src

** Visual appearance

   It is great that you can start out learning Emacs like a normal
   person, using the mouse and navigating through the menu and tool
   bar. However, on a smaller screen I find it a waste of screen
   space.

   #+begin_src emacs-lisp :tangle init.el
     ;; Hide UX we don't want
     (tool-bar-mode -1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)

     (setq frame-resize-pixelwise t)
     (pixel-scroll-mode)
   #+end_src

   We want to have some kind of theme running, the built-in
   =modus-themes= have one bright theme and one dark and ships a
   function to switch between them.

   #+begin_src emacs-lisp :tangle init.el
     (require-theme 'modus-themes)

     ;; We want to italics, but not bold
     (setq modus-themes-italic-constructs t
           modus-themes-bold-constructs nil)
     (load-theme 'modus-operandi)
     ;; Toggle between light and dark themes with f5
     (define-key global-map (kbd "<f5>") #'modus-themes-toggle)
   #+end_src

** Fonts

   The fonts in =font-preferences= are the preferred fonts that I use
   on my system, in descending order. The first font that is available
   will be set as the main font for Emacs.

   #+begin_src emacs-lisp :tangle init.el
     (defun font-existsp (font)
       "Check to see if the named FONT is available."
       (unless (eq window-system nil)
         (if (null (x-list-fonts font)) nil t)))

     (defvar font-preferences '("iosevka term" "Hasklig" "Inconsolata"
    			"Fira Code" "Source Code Pro" "PragmataPro"))

     ;; Set font of new frames to the first available font in
     ;; font-preferences.
     (use-package cl-lib)
     (add-hook 'server-after-make-frame-hook
           (lambda () (let ((fonts (cl-remove-if-not 'font-existsp font-preferences)))
    		    (unless (and (not fonts) (eq window-system nil))
                          (progn
    			(set-face-font 'default (car fonts))
    			(set-face-attribute 'default nil :weight 'medium))))))
   #+end_src

   When programming we would like to make use of ligatures to make the
   font a little nicer.

   #+begin_src emacs-lisp :tangle init.el
     (dolist (char/ligature-re
              `((?-  . ,(rx (or (or "-->" "-<<" "->>" "-|" "-~" "-<" "->") (+ "-"))))
                (?/  . ,(rx (or (or "/==" "/=" "/>" "/**" "/*") (+ "/"))))
                (?*  . ,(rx (or (or "*>" "*/") (+ "*"))))
                (?<  . ,(rx (or (or "<<=" "<<-" "<|||" "<==>" "<!--" "<=>" "<||" "<|>" "<-<"
                                    "<==" "<=<" "<-|" "<~>" "<=|" "<~~" "<$>" "<+>" "</>"
                                    "<*>" "<->" "<=" "<|" "<:" "<>"  "<$" "<-" "<~" "<+"
                                    "</" "<*")
                                (+ "<"))))
                (?:  . ,(rx (or (or ":?>" "::=" ":>" ":<" ":?" ":=") (+ ":"))))
                (?=  . ,(rx (or (or "=>>" "==>" "=/=" "=!=" "=>" "=:=") (+ "="))))
                (?!  . ,(rx (or (or "!==" "!=") (+ "!"))))
                (?>  . ,(rx (or (or ">>-" ">>=" ">=>" ">]" ">:" ">-" ">=") (+ ">"))))
                (?&  . ,(rx (+ "&")))
                (?|  . ,(rx (or (or "|->" "|||>" "||>" "|=>" "||-" "||=" "|-" "|>"
                                    "|]" "|}" "|=")
                                (+ "|"))))
                (?.  . ,(rx (or (or ".?" ".=" ".-" "..<") (+ "."))))
                (?+  . ,(rx (or "+>" (+ "+"))))
                (?\[ . ,(rx (or "[<" "[|")))
                (?\{ . ,(rx "{|"))
                (?\? . ,(rx (or (or "?." "?=" "?:") (+ "?"))))
                (?#  . ,(rx (or (or "#_(" "#[" "#{" "#=" "#!" "#:" "#_" "#?" "#(")
                                (+ "#"))))
                (?\; . ,(rx (+ ";")))
                (?_  . ,(rx (or "_|_" "__")))
                (?~  . ,(rx (or "~~>" "~~" "~>" "~-" "~@")))
                (?$  . ,(rx "$>"))
                (?^  . ,(rx "^="))
                (?\] . ,(rx "]#"))))
       (let ((char (car char/ligature-re))
             (ligature-re (cdr char/ligature-re)))
         (set-char-table-range composition-function-table char
                               `([,ligature-re 0 font-shape-gstring]))))


     ;; Use ligatures in code, but not in prose.
     (use-package composite :ensure nil
         :hook (prog-mode . auto-composition-mode)
         :init (global-auto-composition-mode -1))
   #+end_src

* Org configuration

  Begin the conditional loading:

  #+begin_src emacs-lisp :tangle init.el
    (with-eval-after-load 'org
  #+end_src

 I prefer to have my org files in my =~/personal=

 #+begin_src emacs-lisp :tangle init.el
   (setq org-directory (file-name-as-directory (expand-file-name "~/personal"))
         org-default-notes-file (concat org-directory "organizer.org"))
 #+end_src

 To keep track of my notes and tasks I add some states that my
 notes and tasks could be in. For instance in my reading file,
 items could be READ, READING or WANT-TO-READ. The letters inside
 the parantheses defines keyboard shortcuts that can be used for
 selecting the state of the item. The special characters ~@~ and
 ~!~ defines how logging should be performed. Changing the state
 of an item to a state with a ~@~ prompts you for a note and ~!~
 tells org that it should automatically log timestamp of the state
 change.

 #+begin_src emacs-lisp :tangle init.el
   (setq org-todo-keywords
         '((sequence "IDEAS(i)" "TODO(t)" "URGENT(u@/!)"
                     "IN-PROGRESS(p!/@)" "WAITING(w@/@)"
                     "|" "DONE(d@)" "CANCELLED(c@)")
           (sequence "WANT-TO-READ(@)" "READING(!)" "|" "READ(@)")))
 #+end_src

 Many GTD-apps organize the tasks into projects and contexts, this
 is of course doable inside =Org mode= as well.

 #+begin_src emacs-lisp :tangle init.el
   (setq org-tag-alist '(("@work" . ?w) ("@study" . ?s) ("@coding" . ?c)
                         ("@reading" . ?r) ("@home" . ?h)))
 #+end_src

 When I use org-gcal to synchronize my calendar with Emacs I want
 those files to end up in my calendar.

 #+begin_src emacs-lisp :tangle init.el
   (setq org-agenda-files (list org-directory (concat org-directory "/calendar")))
 #+end_src

 I want to be able to press <TAB> on ~<q~ to it to ~#+begin_quote...~

 #+begin_src emacs-lisp :tangle init.el
   (add-to-list 'org-modules 'org-tempo)
 #+end_src

 I also want the text to follow the indentation from the headers.

 #+begin_src emacs-lisp :tangle init.el
   (setq org-adapt-indentation t)
 #+end_src

 I want org files to be collapsed when they open, so I can quickly
 navigate to the section/header I want to go.

 #+begin_src emacs-lisp :tangle init.el
   (setq org-startup-folded 'content)
 #+end_src

** My files
   :PROPERTIES:
   :CUSTOM_ID: org-files
   :END:

   This is the structure of org files that I want to have and try to
   maintain.

   #<<org-files>>

   | organizer.org   | Main org file, used for org-capture and tasks etc |
   | people.org      | People-related tasks                              |
   | journal.org.gpg | Journal entries (encrypted)                       |
   | studies.org     | Chalmers-related tasks                            |
   | reading.org     | Org file for book notes                           |
   | watching.org    | Org file for stuff I'd like to watch              |

** Org Capture templates

  I want to start using =org-capture= to quickly add tasks and notes
  and organize them in my life.

  Quick legend of the template escape codes:
  - ~%^{PROMPT}~ - Org will prompt me with "PROMPT: " and the input
    will replace the occurrance of ~%^{Task}~ in the template,
  - ~%?~ - Org will put the cursor here so I can edit the capture
    before refiling it,
  - ~%i~ - Org will insert the marked region from before the capture
    here,
  - ~%a~ - Org will insert an annotation here (,
  - ~%U~ - Org will insert an inactive timestamp here,
  - ~%l~ - Org will insert a literal link here,

  #+begin_src emacs-lisp :tangle init.el
    (with-eval-after-load 'org
      (setq org-capture-templates
            `(("t" "Tasks" entry (file+headline ,org-default-notes-file "Inbox")
               "* TODO %^{Task}\nCaptured %<%Y-%m-%d %H:%M> %a\n%?\n\n%i\n")

              ("i" "Interrupting task" entry
               (file+headline ,org-default-notes-file "Inbox")
               "* IN-PROGRESS %^{Task}\n" :clock-in)

              ("j" "Journal entry" plain
               (file+datetree ,(concat org-directory "journal.org.gpg"))
               "%K - %a\n%i\n%?\n")

              ("J" "Journal entry with date" plain
               (file+datetree+prompt ,(concat org-directory "journal.org.gpg"))
               "%K - %a\n%i\n%?\n")

              ("B" "Book" entry
               (file+headline ,(concat org-directory "reading.org") "Books")
               "* WANT-TO-READ %^{Title}  %^g\n\n%i%?\n\n*Author(s)*: %^{Author}\n*Review on:* %^t\n%a %U\n")

              ("A" "Article" entry
               (file+headline ,(concat org-directory "reading.org") "Articles")
               "* WANT-TO-READ %^{Title}  %^g\n\n*Author(s)*: %^{Author}\n\n*Abstract*: %i%?\n\n[[%l][Link to paper]]\n")

              ("p" "Blog post" entry
               (file+headline ,(concat org-directory "reading.org") "Blog entries")
               "* WANT-TO-READ %^{Title}  %^g\n\n%i\n\n*Author(s)*: %^{Author}\n\n[[%l][Link to blog post]]\n")

              ("l" "Bookmark" entry
               (file+headline ,(concat org-directory "bookmarks.org") "Captured entries")
               "* [[%^{Link}][%^{Title}]]\n\n%i%?\n")

              ("n" "Notes" entry (file+datetree ,org-default-notes-file) "* %?\n\n%i\n%U\n")

              ;; Org protocol handlers
              ("pp" "Protocol Blog post" entry
               (file+headline ,(concat org-directory "reading.org") "Blog entries")
               "* WANT-TO-READ %:description  %^g\n\n%i\n\n*Author(s)*: %^{Author}\n\n[[%l][Link to blog post]]\n")

              ("c" "Protocol selection" entry (file+headline ,org-default-notes-file "Inbox")
               "* [[%:link][%:description]] \n\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n%?\n\nCaptured: %U\n")))

      (bind-key "C-M-r" 'org-capture))
  #+end_src

  I then want to be able to capture stuff from the web using
  =org-protocol=.

  #+begin_src emacs-lisp :tangle init.el
    (require 'org-protocol)
    (setq org-protocol-protocol-alist org-protocol-protocol-alist-default)
  #+end_src

** Publishing

  I want to be able to view my org documents so that I can see my
  progress and what I've got left to do and so on. Org publish works
  rather well for this scenario, even though I probably would like
  do some automation on when it does the publishing.

  #+begin_src emacs-lisp :tangle init.el
    (with-eval-after-load 'org
      (require 'ox-html)
      (setq org-publish-project-alist
            `(("html"
               :base-directory ,org-directory
               :base-extension "org"
               :publishing-directory "/ssh:jassob:/var/www/org"
               :recursive t
               :publishing-function org-html-publish-to-html)

              ("org-static"
               :base-directory ,org-directory
               :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
               :publishing-directory "/ssh:jassob:/var/www/org"
               :recursive t
               :publishing-function org-publish-attachment)

              ("archive"
               :base-directory ,org-directory
               :base-extension "org_archive"
               :publishing-directory "/ssh:jassob:/var/www/org/archive"
               :publishing-function org-html-publish-to-html)

              ("web"
               :base-directory ,(concat org-directory "web/")
               :base-extension "org"
               :publishing-directory "/ssh:jassob:/var/www/"
               :publishing-function org-html-publish-to-html)

              ("jassob" :components ("html" "archive" "org-static" "web"))
              ("all" :components ("jassob"))))

      (defun jsb/publish-jassob ()
        "Publishes \"jassob\" project"
        (interactive)
        (org-publish "jassob" t))

      (defun jsb/publish-chalmers ()
        "Publishes \"chalmers\" project"
        (interactive)
        (org-publish "chalmers" t))

      (defun jsb/publish-web ()
        "Publishes \"web\" project"
        (interactive)
        (org-publish "web" t)))
  #+end_src

** Wrapping up

   End conditional loading for org config

   #+begin_src emacs-lisp :tangle init.el
   )
   #+end_src

* Eshell

  I found =Eshell smart display= on the [[https://masteringemacs.org/article/complete-guide-mastering-][Eshell article on Mastering
  Emacs]] and I think it is pretty neat! It lets me review a failing
  command and edit the command line to fix the error.

  #+begin_src emacs-lisp :tangle init.el
    (require 'eshell)
    (require 'em-smart)
    (setq eshell-where-to-jump 'begin)
    (setq eshell-review-quick-commands nil)
    (setq eshell-smart-space-goes-to-end t)
  #+end_src

* Reading / Writing
** Distraction free writing

   Sometimes I just want to have my code (or whatever I'm currently
   reading or writing) presented to me without any other distractions
   and this is where =writeroom-mode= (found [[https://github.com/joostkremers/writeroom-mode][here]]) comes in to play.

   #+begin_src emacs-lisp :tangle init.el
     (use-package writeroom-mode
       :init (setq writeroom-width 120)
       (add-hook 'writeroom-mode-hook (lambda () (display-line-numbers-mode -1)))
       :bind (:map writeroom-mode-map
                   ("C-c C-w <" . #'writeroom-decrease-width)
                   ("C-c C-w >" . #'writeroom-increase-width)
                   ("C-c C-w =" . #'writeroom-adjust-width)
                   ("s-?" . nil)
                   ("C-c C-w SPC" . #'writeroom-toggle-mode-line))
             (:map global-map
                   ("C-c C-M-w" . #'writeroom-mode)))
   #+end_src

** PDFs

   =pdf-tools= is a package that let's me read PDF files within Emacs.

   #+begin_src emacs-lisp :tangle init.el
     (use-package pdf-tools
       :magic ("%PDF" . pdf-view-mode)
       :init (pdf-loader-install :no-query))
   #+end_src

* Experiments

  Here I group every package or feature that I am currently checking
  out, with the hope of time boxing the experiment and either folding
  it into my configuration proper or removing it.

** EVIL mode

   I'm experimenting with EVIL mode in an attempt to learn Vi(m)
   keybindings. Since I am used to quitting and escaping stuff by =C-g=
   I want EVIL to transition to normal mode when I press =C-g=.

   #+begin_src emacs-lisp :tangle init.el
     (defun evil-keyboard-quit ()
       "Keyboard quit and force normal state."
       (interactive)
       (and evil-mode (evil-force-normal-state))
       (keyboard-quit))
   #+end_src

   When EVIL is loaded I therefore want bind =C-g= to
   ~evil-keyboard-quit~.

   #+begin_src emacs-lisp :tangle init.el
     (use-package evil :commands 'evil-mode
       :bind
       (:map evil-normal-state-map   ("C-g" . #'evil-keyboard-quit))
       (:map evil-motion-state-map   ("C-g" . #'evil-keyboard-quit))
       (:map evil-motion-state-map   ("C-g" . #'evil-keyboard-quit))
       (:map evil-insert-state-map   ("C-g" . #'evil-keyboard-quit))
       (:map evil-window-map         ("C-g" . #'evil-keyboard-quit))
       (:map evil-operator-state-map ("C-g" . #'evil-keyboard-quit)))
   #+end_src


* TODO Add linters and formatters to common-code-mode
  Variable =buffer-file-name= could be used together with a asynch
  shell command.
* TODO Add work configuration
  Add work config where browse-url opens links in Chrome etc.
* TODO Check out byte-compiled errors
  When the code is byte-compiled there are some stuff that is not
  found, might be worth investigating whether (eval-and-compile) works
  better.
* TODO Integrate better with Nix
  [[https://matthewbauer.us/bauer/#emacs][This]] is very interesting, maybe something I might take advantage of
  myself?
* TODO Move common-code-mode into prog-mode
